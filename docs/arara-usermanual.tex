% arara: pdflatex
% arara: pdflatex
% arara: biber
% arara: pdflatex
% arara: pdflatex
% arara: clean: { files: [ arara-usermanual.aux, arara-usermanual.bbl ] }
% arara: clean: { files: [ arara-usermanual.bcf, arara-usermanual.cod ] } 
% arara: clean: { files: [ arara-usermanual.blg, arara-usermanual.lof ] }
% arara: clean: { files: [ arara-usermanual.lot, arara-usermanual.out ] } 
% arara: clean: { files: [ arara-usermanual.toc, arara-usermanual.log ] } 
% arara: clean: { files: [ arara-usermanual.run.xml ] }
% -------------------------------------------------
% Arara -- the cool TeX automation tool
% Copyright (c) 2012, Paulo Roberto Massa Cereda
% All rights reserved.
%
% Redistribution and  use in source  and binary forms, with  or without
% modification, are  permitted provided  that the  following conditions
% are met:
%
% 1. Redistributions  of source  code must  retain the  above copyright
% notice, this list of conditions and the following disclaimer.
%
% 2. Redistributions in binary form  must reproduce the above copyright
% notice, this list  of conditions and the following  disclaimer in the
% documentation and/or other materials provided with the distribution.
%
% 3. Neither  the name  of the  project's author nor  the names  of its
% contributors may be used to  endorse or promote products derived from
% this software without specific prior written permission.
%
% THIS SOFTWARE IS  PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS
% "AS IS"  AND ANY  EXPRESS OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT
% LIMITED  TO, THE  IMPLIED WARRANTIES  OF MERCHANTABILITY  AND FITNESS
% FOR  A PARTICULAR  PURPOSE  ARE  DISCLAIMED. IN  NO  EVENT SHALL  THE
% COPYRIGHT HOLDER OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT,
% INCIDENTAL, SPECIAL, EXEMPLARY,  OR CONSEQUENTIAL DAMAGES (INCLUDING,
% BUT  NOT LIMITED  TO, PROCUREMENT  OF SUBSTITUTE  GOODS OR  SERVICES;
% LOSS  OF USE,  DATA, OR  PROFITS; OR  BUSINESS INTERRUPTION)  HOWEVER
% CAUSED AND  ON ANY THEORY  OF LIABILITY, WHETHER IN  CONTRACT, STRICT
% LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
% WAY  OUT  OF  THE USE  OF  THIS  SOFTWARE,  EVEN  IF ADVISED  OF  THE
% POSSIBILITY OF SUCH DAMAGE.
% -------------------------------------------------

\documentclass[a4paper,twoside,12pt]{memoir}

% packages
% -------------------------------------------------
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{arara}
% -------------------------------------------------

% bibliography
% -------------------------------------------------
\addbibresource{references.bib}
% -------------------------------------------------

% current version
% -------------------------------------------------
\newcommand{\araraversion}{3.0}
% -------------------------------------------------

% document
% -------------------------------------------------
\begin{document}

% title page
% -------------------------------------------------
\begin{titlingpage}

\begin{center}
\vspace*{2em}

\scalebox{1.15}{\araralogo}

\vspace{2em}

{\color{araracolor}\fontfamily{fco}\bfseries\Huge The cool \TeX{} automation tool}

\vspace{10em}

{\Huge\sffamily\bfseries User Manual}

\vspace{3em}

{\large
\tabcolsep=1em
\begin{tabular}{cc}
\multicolumn{2}{c}{Paulo R.\ M.\ Cereda}\\
\multicolumn{2}{c}{\url{cereda@users.sf.net}}\\[1.5em]
Marco Daniel & Brent Longborough\\
\url{marco.daniel@mada-nada.de} & \url{brent@longborough.org}
\end{tabular}}

\vfill

{\LARGE\sffamily\bfseries Version \araraversion}

\end{center}

\end{titlingpage}
% -------------------------------------------------

% set styles
% -------------------------------------------------
\chapterstyle{madsen}
\pagestyle{headings} 
\frontmatter
\nouppercaseheads
% -------------------------------------------------

% Prologue
% -------------------------------------------------
\chapter*{Prologue}
\label{chap:prologue}

\epigraph{\emph{Moral of the story: never read the documentation, bad things happen.}}{David Carlisle}

When I released the very first version of \arara on a Friday 13th, April 2012, I never thought the tool would
receive so many positive comments and feedback. To be honest, since \arara was written for helping me
with my own personal \LaTeX\ projects, I really doubted if the tool could be of service to anyone else. And,
to my surprise, it seems \arara did good. To a lot of people around the \TeX\ world.

I never intended to release the tool to the whole world, since I wasn't sure if other people could benefit from
\arara's features. After all, there's already a plethora of tools available to the \TeX\ community in general,
although with different approaches. The reason I decided to make \arara publicly available is quite simple:
I wanted to somehow contribute to the \TeX\ community, and I wanted to give my best to make such
community even more awesome.

As time goes by, I'm quite satisfied with the current state of \arara~--~this is our 3rd major release. We
have reached a very mature code and a great team of developers, translators and testers. Since version 1.0,
the code evolved a lot -- new features, lots of bug fixes, improvements -- thanks to all the feedback I
received. In my humble opinion, that's how any project should evolve: based on what our users expect and
want to achieve. I'm proud to see \arara being 100\% community-driven, it's a big achievement for a project
with less than one year old.

First of all, I'd like to thank some friends of mine that really made \arara possible: Alan Munn, for providing
great ideas and suggestions to the manual; Andrew Stacey, for heavily testing \arara, providing great user
cases, and for suggesting improvements to the program; Brent Longborough, a member of the core team,
for providing great suggestions and ideas to the program logic, writing rules, testing the code and also for
working with the Portuguese and Turkish translations; Clemens Niederberger, for testing \arara, and also
writing a great tutorial about it in his
\href{http://www.mychemistry.eu/2012/06/arara-automate-latex-birds-music/}{blog on chemistry and \LaTeX};
David Carlisle, for reminding me to work on \arara, and also encouraging me to write answers about it in
our \TeX\ community; Enrico Gregorio, for reviewing the original manual, testing \arara, providing great
ideas and suggestions to the manual and to the program itself, and for working with the Italian translation;
Francesco Endrici, for providing the very first \arara rule outside our core team; Harish Kumar, for being a
heavy \arara user and integrating it with WinEdt and Inlage; \.Ilhan Polat for working with Brent in the Turkish
translation; Joseph Wright, for testing it, providing contributed code for Linux and Mac installations, and also
blogging about \arara in his \href{http://www.texdev.net}{personal blog}; Gonzalo Medina, for providing the
Spanish translation; Mikaël Maunier, for providing the French translation; Marco Daniel, one of core team
members, for heavily testing \arara, suggesting enhancements to the manual and to the program itself,
providing lots of contributed rules for common tasks, and also for the German version; Patrick Gundlach,
for advertising \arara in the official Twitter channel of \href{http://www.dante.de}{Dante} -- the German
\TeX\ User Group; Sergey Ulyanov, for providing the Russian translation and contributed rules; Stefan Kottwitz,
for encouraging me to write an article about \arara, published in the
\href{http://latex-community.org/know-how/435-gnuplot-arara}{\LaTeX\ Community} forum, and also
tweeting about it. Thank you very much. I'm sorry if I forgot to mention somebody, I really have so much
people to thank and my memory happens to be very short.

That said, I still believe that the warning featured in the first version of this manual still applies:
\textsc{Hic Sunt Dracones}. Though the code really evolved from the first commit I made, \arara is far from
being bug-free. And you will learn that \arara gives you enough rope. In other words, \emph{you} will be
responsible for how \arara behaves and all the consequences from your actions. Sorry to sound scary, but I
really needed to tell you this. After all, one of \arara's greatest features is the freedom it offers. But as you
know, freedom always comes at a cost. Please, don't send us angry letters -- or e-mails, perhaps -- if
something bad happen.

Feedback is surely welcome for me to improve this humble tool, just write an e-mail to me or any other
member of the team and we will reply as soon as possible. The source code is fully available at
\url{http://github.com/cereda/arara}, feel free to contribute to the project by forking it, submitting bugs,
sending pull requests or even translating it to your language. If you want to support the \LaTeX\ development
by a donation, the best way to do this is donating to the \href{http://www.tug.org/}{\TeX\ Users Group}.
Please also  consider joining our \TeX\ community at \href{http://tex.stackexchange.com}{StackExchange}.

\vspace{2em}

\begin{flushright}
Paulo Roberto Massa Cereda\\
\emph{on behalf of the \arara team}
\end{flushright}

%\vspace{8em}
\vfill

\begin{center}
\scalebox{0.55}{\araralogo}

\vspace{0.3em}

{\color{araracolor}\fontfamily{fco}\bfseries\large Proudly made on Earth}
\end{center}
% -------------------------------------------------

\cleardoublepage

% Special thanks
% -------------------------------------------------
\section*{Special thanks}

\begin{mdframed}[roundcorner=10pt,linecolor=araracolor,middlelinewidth=1pt]
\centering
{\renewcommand{\arraystretch}{1.5}
\sffamily
\begin{tabular}{ccc}
Alan Munn & Andrew Stacey & Brent Longborough\\
Clemens Niederberger & David Carlisle & Enrico Gregorio\\
Francesco Endrici & Harish Kumar & \.Ilhan Polat\\
Joseph Wright & Gonzalo Medina & Mikaël Maunier\\
Marco Daniel & Patrick Gundlach & Sergey Ulyanov\\
Stefan Kottwitz & &
\end{tabular}}
\end{mdframed}

\vspace{1em}

\noindent\arara also makes use of some specific opensource Java projects and libraries in order to properly
work. I would like to thank the following projects and their respective developers:

\begin{enumerate}
\item \href{http://commons.apache.org}{Apache Commons}, a project from the Apache Foundation focused
on all aspects of reusable Java components. \arara uses three of the Commons libraries:
\href{http://commons.apache.org/cli/}{CLI}, which provides a command line arguments parser,
\href{http://commons.apache.org/collections/}{Collections}, a library which extends the Java Collections
Framework, and \href{http://commons.apache.org/exec/}{Exec}, an API for dealing with external process
execution and environment management in Java.

\item \href{http://logback.qos.ch}{Logback}, a logging framework intended to be the successor to the
popular \href{http://logging.apache.org/log4j/}{log4j} project. According to some benchmarks, it is faster
and has a smaller footprint than all existing logging systems, sometimes by a wide margin.

\item \href{http://code.google.com/p/snakeyaml}{SnakeYAML}, a YAML parser and emitter for the Java
programming language. YAML is a data serialization format designed for human readability and interaction
with scripting languages. \arara uses YAML as the rule format.

\item \href{http://www.slf4j.org/}{SLF4J}, a simple facade or abstraction for various logging frameworks,
allowing the end user to plug in the desired logging framework at deployment time.

\item \href{http://mvel.codehaus.org}{MVEL}, a powerful expression language for Java-based applications.
It provides a plethora of features and is suited for everything from the smallest property binding and extraction,
to full blown scripts. \arara relies on MVEL to provide the expansion mechanism for rules.

\item \href{http://maven.apache.org/}{Apache Maven}, a software project management and comprehension tool.
Based on the concept of a project object model, Maven can manage a project's build, reporting and documentation
from a central piece of information. 

\item \href{http://izpack.github.com}{IzPack}, a Java-based software installer builder that will run on any
operating system coming with a Java Virtual Machine that is compliant with the Oracle JVM 1.5 or higher.
\end{enumerate}

A special thanks goes to my great friend \href{http://antoineneveux.fr/}{Antoine Neveux} for encouraging me to
try out the \href{http://maven.apache.org}{Apache Maven} software project management. In the past, \arara was
released as a NetBeans project, which is based on \href{http://ant.apache.org/}{Apache Ant}, another great tool
from the Apache Foundation. Although I'm really fine with Ant, thanks to Maven, now it is way easier to build and
to maintain the code. And it's always nice to learn another tool.

And at last but not least, I want to thank you, dear reader and potential user, for giving \arara a try. Do not despair
if you don't succeed with \arara at first; just try again. I'm sure you will find your way. This humble project is
opensource and it will always be. Let the bird be your guide through the journey to the typographic land. Have a
good read.
% -------------------------------------------------

\cleardoublepage

% Release information
% -------------------------------------------------
\section*{Release information}

\subsection*{Version 3.0}
\begin{itemize}
\item[\newfeature] 
     % TODO
     List of new features and a table containing the lines of code for
     version 3.0.
\end{itemize}

{\renewcommand{\arraystretch}{1.5}
\begin{table}[ht]
\centering
\caption{Lines of code for version 3.0.}
\begin{tabular}{lrrrr}
\hline
\textbf{Language} & \textbf{Files} & \textbf{Blank} & \textbf{Comment} & \textbf{Code}\\
\hline
\hline
Java & 0 & 0 & 0 & 0\\
XML & 0 & 0 & 0 & 0\\
\hline
Sum & 0 & 0 & 0 & 0\\
\hline
\end{tabular}
\label{tab:locarara30}
\end{table}}

\subsection*{Version 2.0}
\begin{itemize}
\item[\newfeature] 
     Added the |--timeout n| flag to allow setting a timeout for every task. If
     the timeout is reached before the task ends, \arara will kill it and 
     interrupt the processing. The $n$ value is expressed in milliseconds.
\item[\bugfix] 
     Fixed the |--verbose| flag to behave as a realtime output.
\item[\newfeature] 
     There's no need of noninteractive commands anymore. \arara can now handle
     user input through the |--verbose| tag. If the flag is not set and the 
     command requires user interaction, the task execution is interrupted.
\item[\bugfix] 
     Fixed the execution of some script-based system commands to ensure 
     cross-platform compatibility.
\item[\newfeature] 
     Added the |@{SystemUtils}| orb tag to provide specific operating system 
     checks. The orb tag maps the |SystemUtils| class from the amazing 
     \href{http://commons.apache.org/lang/}{Apache Commons Lang} library and 
     all of its methods and properties.
\end{itemize}

{\renewcommand{\arraystretch}{1.5}
\begin{table}[ht]
\centering
\caption{Lines of code for version 2.0.}
\begin{tabular}{lrrrr}
\hline
\textbf{Language} & \textbf{Files} & \textbf{Blank} & \textbf{Comment} & \textbf{Code}\\
\hline
\hline
Java & 20 & 608 & 1642 & 848\\
XML & 1 & 0 & 0 & 12\\
\hline
Sum & 21 & 608 & 1642 & 860\\
\hline
\end{tabular}
\label{tab:locarara20}
\end{table}}

\subsection*{Version 1.0.1}

\begin{itemize}
\item[\newfeature] 
     Added support for |.tex|, |.dtx| and |.ltx| files. When no extension is 
     provided, \arara will automatically look for these extensions in this 
     specific order.
\item[\newfeature] 
     Added the |--verbose| flag to allow printing the complete log in the 
     terminal. A short |-v| tag is also available. Both |stdout| and |stderr| 
     are printed.
\item[\bugfix] 
     Fixed exit status when an exception is thrown. Now \arara also returns a 
     non-zero exit status when something wrong happened. Note that this 
     behaviour happens only when \arara is processing a file.
\end{itemize}

{\renewcommand{\arraystretch}{1.5}
\begin{table}[ht]
\centering
\caption{Lines of code for version 1.0.1.}
\begin{tabular}{lrrrr}
\hline
\textbf{Language} & \textbf{Files} & \textbf{Blank} & \textbf{Comment} & \textbf{Code}\\
\hline
\hline
Java & 20 & 585 & 1671 & 804\\
XML & 1 & 0 & 6 & 12\\
\hline
Sum & 21 & 585 & 1677 & 816\\
\hline
\end{tabular}
\label{tab:locarara101}
\end{table}}

\subsection*{Version 1.0}

\begin{itemize}
\item[\newfeature] First public release.
\end{itemize}

{\renewcommand{\arraystretch}{1.5}
\begin{table}[ht]
\centering
\caption{Lines of code for version 1.0.}
\begin{tabular}{lrrrr}
\hline
\textbf{Language} & \textbf{Files} & \textbf{Blank} & \textbf{Comment} & \textbf{Code}\\
\hline
\hline
Java & 20 & 524 & 1787 & 722\\
XML & 1 & 0 & 6 & 12\\
\hline
Sum & 21 & 524 & 1793 & 734\\
\hline
\end{tabular}
\label{tab:locarara10}
\end{table}}
% -------------------------------------------------

\cleardoublepage

% License
% -------------------------------------------------
\section*{License}
\label{sec:license}

\arara is licensed under the 
\href{http://www.opensource.org/licenses/bsd-license.php}{New BSD License}. It's
important to observe that the New BSD License has been verified as a 
GPL-compatible free software license by the 
\href{http://www.fsf.org/}{Free Software Foundation}, and has been vetted as an 
open source license by the 
\href{http://www.opensource.org/}{Open Source Initiative}.

\vspace{1.5em}

\ornamentline

\vfill

\begin{mdframed}[roundcorner=10pt,linecolor=araracolor,middlelinewidth=1pt]
\noindent
\begingroup
  \color{araracolor}\fontfamily{fco}\bfseries
  \arara \ -- the cool \TeX{} automation tool
\endgroup

\vspace{.5em}

\noindent Copyright \copyright{} 2012, Paulo Roberto Massa Cereda

\noindent All rights reserved.

\vspace{1em}

\noindent Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

\vspace{1em}

\begin{itemize}
\item Redistributions of source code must retain the above copyright notice, 
      this list of conditions and the following disclaimer.
\item Redistributions in binary form must reproduce the above copyright notice,
      this list of conditions and the following disclaimer in the documentation
      and/or other materials provided with the distribution.
\end{itemize}

\vspace{1em}

\noindent\textsc{This software is provided by the copyright holders and 
contributors ``as is'' and any express or implied warranties, including, but not
 limited to, the implied warranties of merchantability and fitness for a 
particular purpose are disclaimed. In no event shall the copyright holder or 
contributors be liable for any direct, indirect, incidental, special, exemplary,
 or consequential damages (including, but not limited to, procurement of 
substitute goods or services; loss of use, data, or profits; or business 
interruption) however caused and on any theory of liability, whether in contract,
 strict liability, or tort (including negligence or otherwise) arising in any 
way out of the use of this software, even if advised of the possibility of such
damage.}
\end{mdframed}
% -------------------------------------------------

\cleardoublepage

\vspace*{25em}

\begin{flushright}
\em To my cat Fubá, who loves birds.
\end{flushright}

\cleardoublepage

% TOC and list of codes
% -------------------------------------------------
\tableofcontents*

\cleardoublepage

\listoffigures*

\cleardoublepage

\listoftables*

\cleardoublepage

\listofcodes*
% -------------------------------------------------

\mainmatter

\part{The application}
\label{part:application}

\chapter{Introduction}
\label{chap:introduction}

\epigraph{\emph{You can do such a lot with a Wompom, you can use every part of it too.
For work or for pleasure, it's a triumph, it's a treasure,
oh there's nothing that a Wompom cannot do.}}{Flanders \& Swann}

Hello there, welcome to \arara! I'm glad you were not intimidated by the threatening
message in the prologue. This chapter is actually a quick introduction to what you
can expect from \arara. Don't be afraid, it will be easy to digest, I promise.

\section{What is \texorpdfstring{\arara}{arara}?}
\label{sec:whatisarara}

Good question! \arara is a \TeX\ automation tool based on rules and directives. It is,
in some aspects, similar to other well-known tools like |latexmk|~\cite{collins:2001}
and |rubber|~\cite{rubber:2009}. The key difference might be the fact that \arara
aims at explicit instructions in the source code in order to determine what to do instead
of relying on other resources, such as log file analysis. It's a different approach for an automation tool, and
we have both advantages and disadvantages of such decision. Let's talk about
disadvantages first.

Since we need to explicitly tell \arara what we want it to do, it might not be intuitive
for casual users. Tools like |latexmk| and |rubber| rely on a analysis scheme in which
the document is generated with a simple call to |latexmk mydoc.tex| or |rubber --pdf mydoc.tex|,
while a similar call to |arara mydoc.tex| does absolutely nothing; it's not wrong, it's by design:
\arara needs to know what you want. We do this by adding a directive in our |.tex| file, as shown
in line~1 of Code~\ref{code:hellolatex}. Don't worry with the terms now, we will come back to the
concepts later on in this manual, in Chapter~\ref{chap:importantconcepts}.

\begin{code}[htbp]
\caption{\mycmd{mydoc.tex}}
\label{code:hellolatex}
\begin{latex}
% (*@@*)arara: pdflatex
\documentclass{article}

\begin{document}
Hello world.
\end{document}
\end{latex}
\end{code}

When we add a directive in our source code, we are explicitly telling \arara what we want it to do,
but I'm afraid that's not sufficient. So far, \arara knows \emph{what} to do, but now it needs to know
\emph{how} the task should be done. Then, for every directive, we need to have an associated rule.
In other words, if we want \arara to run |pdflatex| on |mydoc.tex|, we need to have a set of instructions
which tells our tool how to run that specific application. Although the core team provides a lot of rules
shipped with \arara out of the box, with the possibility of extending the set by adding more rules,
some users might find this decision rather annoying, since other tools have most of their rules hardcoded,
making the automation process even more transparent.

Now, let's talk about some advantages. In my humble opinion, since \arara doesn't rely on a specific
automation or compilation scheme, it becomes more extensible. The use of directives in the source code
make the automation steps more fluent, which allows the specification of complex workflows very easily.
Maybe \arara's verbosity on automation steps might not be suitable for small documents, but the tool
really shines when you have a document which needs full control of the automation process.

Another advantage that comes to my mind right now is the fact that directives and rules can be parametrized.
In other words, you can create conditional branches, execution workflows based on parameters, flags, and so
on, by simply providing a parameter in a directive. Besides, \arara also provides a lot of helper functions
in order to enhance rules; for example, you can have a rule which executes a certain command when in Windows,
and a different one when in Unix.

The rules are written in a human-readable format. The reason for this decision came as an attempt to simplify
the life of many casual users which are not versed into programming. Sadly, writing complex XML mappings or
even deliberately injecting code into an application is not a trivial task, so we opted for an easy way of declaring
the set of instructions that tells \arara how to do a task. We will discuss about the format later on, in Section~\ref{sec:rules}.

Now that \arara was properly introduced, let me explain the meaning of the name. \emph{Arara} is the Brazilian
name of a macaw bird (Figure~\ref{fig:arara}). Have you ever watched \emph{Rio: the movie}, produced by Blue
Sky Studios? The protagonist is a blue arara. The word \emph{arara} comes from the Tupian word \emph{a'rara},
which means \emph{big bird}~\cite{tupi:2012}.

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.6]{figures/arara.png}
\caption{A lovely photo of an arara.}
\label{fig:arara}
\end{figure}

Lovely bird, isn't it? Now, you are probably wondering why I chose this name. Well, araras are colorful, noisy,
naughty and very funny. Everybody loves araras. So why can't you love a tool with the very same name? And
there is also another motivation of the name \emph{arara}: the chatroom residents of 
\href{http://chat.stackexchange.com/rooms/41}{\TeX.sx} -- including myself -- are fans of palindromes,
especially palindromic numbers. As you can already tell, \emph{arara} is a palindrome.

\section{How does it work?}
\label{sec:howdoesitwork}

Now that we know what \arara is, let's take a look on how the tool actually works. The whole idea is pretty
straightforward, but some concepts might be confusing at first. Do not despair, we will come back to
them later on in the manual, in Chapter~\ref{chap:importantconcepts}.

First of all, we need to add at least one instruction in the source code to tell \arara what to do. This instruction
is named \emph{directive} and it will be parsed during the preparation phase. By default, an \arara directive is
defined in a line of its own, started with a comment, followed by the word |arara:|  and the name of the task.
Code~\ref{code:hellolatex} has one directive, referencing |pdflatex|. It's important to observe that |pdflatex|
is not the command to be executed, but the name of the rule associated with that directive.

Once \arara finds a directive, it will look for the associated \emph{rule}. In our example, it will look for a rule named
|pdflatex| which will evidently run the |pdflatex|  command line application. The rule is analyzed, all possible
parameters are defined, the command line call is built and then it goes to a queue of commands to be executed.

After extracting all directives from a source code and mapping each one of them to their respective rules, \arara
then executes the queue of commands. The execution chain requires that the command $i$ was successfully
executed to then proceed to the command $i+1$, and so forth. This is also by design: \arara will halt the execution
if any of the commands in the queue had raised an error. If we run \arara on |mydoc.tex| -- we can also run
|arara mydoc| too, we will discuss this later on -- presented in Code~\ref{code:hellolatex}, we get the output
presented in Code~\ref{code:araraoutputexample}.

\begin{code}[htbp]
\caption{Running \arara on \mycmd{mydoc.tex}.}
\label{code:araraoutputexample}
\begin{bash}
$ arara mydoc
  __ _ _ __ __ _ _ __ __ _
 / _` | '__/ _` | '__/ _` |
| (_| | | | (_| | | | (_| |
 \__,_|_|  \__,_|_|  \__,_|

Running PDFLaTeX... SUCCESS
\end{bash}
\end{code}

That is pretty much how \arara works: directives in the source code are mapped to rules, which are converted to
commands and added to a queue. The queue is then executed and the status is reported. We will cover more details
about the expansion process later on in the manual. In short, we teach \arara to do a task by providing a rule,
and tell it to execute it via directives in the source code.

\section{Features}
\label{sec:features}

To name a few features I like in \arara, I'd mention the ability to write rules in a human-readable format called YAML,
which rhymes with the word \emph{camel}. YAML is actually a recursive acronym for \emph{YAML Ain't Markup Language},
and it's known as a human friendly data serialization standard for all programming languages~\cite{yaml:2001}. So far,
I think this format is quite suitable to write rules, specially if you want to avoid the need of writing complicated XML mappings or
even injecting code directly into the application.

Another feature worth mentioning is the fact that \arara is platform independent. The application was written in Java,
so \arara runs on top of a Java virtual machine, available on all the major operating systems~--~in some cases, you
might need to install the proper virtual machine. We tried very hard to keep both code and libraries compatible with
older virtual machines or from other vendors. Currently, \arara is known to run on Oracle's Java 5, 6 and 7, and OpenJDK 6 and 7.
In Chapter~\ref{chap:buildingfromsources}, there are instructions on how to build \arara from sources. Even if
you use multiple operating systems, \arara should behave the same, including the rules. There are helper functions
available in order to provide support for system-specific rules based on the underlying operating system, presented
in Section~\ref{sec:functions}.

From version 3.0 on, \arara can now display localized messages. The default language is set to English, but the user can
receive feedback from the execution process and logging in other languages as well, such as Brazilian Portuguese, German,
Italian, French, Spanish, Russian and Turkish. There's also a way to redefine the default language by adding an entry in the configuration
file, discussed later on in Section~\ref{sec:language}.

Speaking of which, \arara has now an optional configuration file in which we can add rule paths, set the default language and
define custom extensions and directive patterns, located in the user home directory. That way, we can extend \arara's behaviour
to deal with other extensions, such as |.c| files, and use the tool with other formats. We will come back on this subject later on
in Chapter~\ref{chap:configurationfile}.

\arara is also easily integrated with other \TeX\ integrated development environment, such as \TeX works~\cite{texworks:2009}, an 
environment for authoring \TeX\ documents shipped with both \TeX\ Live and MiK\TeX. Chapter~\ref{chap:ideintegration} covers
the integration of \arara with several environments.

\section{Common uses}
\label{sec:commonuses}

\arara can be used in complex workflows, like theses and books. You can tell \arara to compile the document, generate
indices and apply styles, remove temporary files, compile other |.tex| documents, create glossaries, call |pdfcrop|, move files,
run \hologo{METAPOST} or \hologo{METAFONT}, and so forth. You can easily come up with your own rules.

There's an \href{http://latex-community.org/know-how/435-gnuplot-arara}{article} available in the \LaTeX\ community which
describes the integration of |gnuplot| and \arara~\cite{cereda:2012}. This article was submitted as an entry to a contest organized
by Stefan Kottwitz. It might be worth a read.

Let's see a few examples. Code~\ref{code:exlatexone} contains the workflow I used for another article I recently wrote. Note that the first call to
|pdflatex| creates the |.aux| file, then |bibtex| will extract the cited publications. The next calls to |pdflatex| will insert
and refine the references.

\begin{code}[htbp]
\caption{\mycmd{article.tex}}
\label{code:exlatexone}
\begin{latex}
% (*@@*)arara: pdflatex
% (*@@*)arara: bibtex
% (*@@*)arara: pdflatex
% (*@@*)arara: pdflatex
\documentclass[journal]{IEEEtran}
...
\end{latex}
\end{code}

Code~\ref{code:exlatextwo} contains another workflow I used for a manual. I had to use a package that required shell escape,
so the calls to |pdflatex| had to enable it. Also, I had an index with a custom formatting, then |makeindex| was called with the
 proper style.

\begin{code}[htbp]
\caption{\mycmd{manual.tex}}
\label{code:exlatextwo}
\begin{latex}
% (*@@*)arara: pdflatex: { shell: yes }
% (*@@*)arara: makeindex: { style: mystyle }
% (*@@*)arara: pdflatex: { shell: yes }
% (*@@*)arara: pdflatex: { shell: yes }
\documentclass{book}
...
\end{latex}
\end{code}

And of course, the \arara user manual is also compiled with |arara|. You can take a look in the source code and check the
header. By the way, note that I had to use a trick to avoid |arara| to read the example directives in this manual. As we will
see later, \arara reads directives everywhere. Actually, I could have changed the directive pattern for |.tex| files through
the configuration file, but that's another story.

Other workflows can be easily created. There can be an arbitrary number of instructions for \arara to execute, so feel free to
come up with your own workflow. \arara will handle it for you. My friend Joseph Wright wrote a great article about \arara in
his personal blog, it's really worth a read~\cite{wright:2012}.

I really hope you like my humble contribution to the \TeX\ community. Let \arara enhance your \TeX\ experience, it will help you
when you'll need it the most. Enjoy the manual.

\printbibliography[heading=subbibliography]

\chapter{Installation}
\label{chap:installation}

\epigraph{\emph{Adjust \texttt{\string\hsize}: old man Fermat couldn't.}}{Enrico Gregorio}

Spledid, so you decided to give \arara a try? This chapter will cover the installation procedure. We basically
have two methods of installing \arara: the first one is through a cross-platform installer, which is of course
the recommended method; the second one is a manual deployment, with the provided |.jar| file -- a
self-contained, batteries-included executable Java archive file. If you have a recent \TeX\ Live distribution,
good news: \arara is already available in your system!

\section{Prerequisites}
\label{sec:prerequisites}

I know I've mentioned this before in Section~\ref{sec:features} and, at the risk of being repetitive, there we
go again: \arara is written in Java and thus depends on a virtual machine in the underlying operating system.
If you use a Mac or even a fairly recent Linux distribution, I have good news for you: it's mostly certain that
you already have a Java virtual machine installed.

It's very easy to check if you have a Java virtual machine installed: try running |java -version| in the terminal
(bash, command prompt, you name it) and see if you get an output similar to the one provided in
Code~\ref{code:javainstalled}.

\begin{code}[htbp]
\caption{Checking if \mycmd{java} is installed.}
\label{code:javainstalled}
\begin{bash}
$ java -version
java version "1.6.0_24"
OpenJDK Runtime Environment (IcedTea6 1.11.1)
OpenJDK Client VM (build 20.0-b12, mixed mode)
\end{bash}
\end{code}

If the output goes along the lines of |java: command not found|, I'm afraid you don't have a Java virtual
machine installed in your operating system. Since the virtual machine is a prerequisite for \arara to run,
you can install one via your favorite package manager or manually install it from the binaries available
in the official \href{http://www.java.com}{Java website}. Make sure to download the correct version for
your operating system. The installation procedure is very straightforward. If you get stuck, take a look
on the installation instructions.

It's important to mention that \arara runs also with the Java virtual machine from the OpenJDK
project~\cite{openjdk:2006}, which is already available in most of the recent Linux distributions -- actually
the output from Code~\ref{code:javainstalled} shows the OpenJDK version from my Fedora machine.
Feel free to use the virtual machine you feel most comfortable with.

Speaking of virtual machines, \arara requires at least Java 5 to run. Don't worry, it's quite easy to spot the Java
version: just look at the second digit of the version string. For example, Code~\ref{code:javainstalled} outputs |1.6.0_24|, 
which means we have Java 6 installed.

\section{Obtaining \texorpdfstring{\arara}{arara}}
\label{sec:obtainingarara}

Before proceeding, we need to choose the installation method. We have two options: the first option is the easiest one,
which installs \arara through a cross-platform installer; the second option is a manual deployment.

From version 3.0 on, \arara is also available as part of the \TeX\ Live distribution. If you have a recent \TeX\ distro,
it's almost certain that you already have \arara; make sure to select it in the |tlmgr| application.

If we opt for the installer, go to the \href{http://github.com/cereda/arara/downloads}{downloads} section of the project
 repository and download |arara-3.0-installer.jar| for all operating systems or |arara-3.0-installer.exe| for Windows.
Please note that the |.exe| version is only a wrapper which will launch |arara-3.0-installer.jar| under the hood. The 
installer also requires Java.

If we want to do things the complicated way, go to the \href{http://github.com/cereda/arara/downloads}{downloads}
section of the project repository and download the |arara.jar| file, which is a self-contained, batteries-included executable
Java archive file.

In case you want to build \arara from source, please refer to Chapter~\ref{chap:buildingfromsources} which will
cover the whole process. Thanks to Apache Maven, the build process is very easy.

\section{Using the cross-platform installer}
\label{sec:usingthecrossplatforminstaller}

After downloading |arara-3.0-installer.jar| (or its |.exe| counterpart), it's now just a matter of running it.
The installer is built with IzPack~\cite{izpack:2001}, an amazing tool for packaging applications on the Java 
platform. Of course the source is also available at the project repository. Personally, I suggest you to run the
installer in privileged mode, but you can also run it in user mode -- just keep in mind that some features might
not work, like creating symbolic links or adding the application to the system path, which inevitably requires a
privileged mode.

When running |arara-3.0-installer.jar| or its |.exe| wrapper on Windows by simply double-clicking it, the installer
will automatically run in privileged mode. A general Unix-based installation can be triggered by the command
presented in Code~\ref{code:runinstaller1}. There's also an alternative command presented in 
Code~\ref{code:runinstaller2}.

\begin{code}[htbp]
\caption{Running the installer in a Unix-based system -- method 1.}
\label{code:runinstaller1}
\begin{bash}
$ sudo java -jar arara-3.0-installer.jar
\end{bash}
\end{code}

\begin{code}[htbp]
\caption{Running the installer in a Unix-based system -- method 2.}
\label{code:runinstaller2}
\begin{bash}
$ su -c 'java -jar arara-3.0-installer.jar'
\end{bash}
\end{code}

Since Windows doesn't have a similar command to |su| or |sudo|, you need to open the command prompt as
administrator and then run the command presented in Code~\ref{code:runinstallerwin}. You can right-click
the command prompt shortcut and select the ``Run as administrator\ldots'' option.

\begin{code}[htbp]
\caption{Running the installer in the Windows command prompt as administrator.}
\label{code:runinstallerwin}
\begin{bash}
C:\> java -jar arara-3.0-installer.jar
\end{bash}
\end{code}

The installation process will begin. Hopefully, the first screen of the installer will appear, which is the
language selection (Figure~\ref{fig:instlang}). By the way, if you called the installer through the command line,
please do not close the terminal! It might end the all running processes, including our installer.

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.5]{figures/install-langsel.png}
\caption{Language selection screen.}
\label{fig:instlang}
\end{figure}

% TODO add more languages
The installer currently supports six languages: English, German, French, Italian, Spanish, and Brazilian Portuguese.
I plan to add more languages to the list in the near feature.

The next screen welcomes you to the installation (Figure~\ref{fig:instwelcome}). There's the application name, the
current version, the team, and the project homepage. We can proceed by clicking the \textit{Next} button. 
Note that you can quit the installer at any time by clicking the \textit{Quit} button -- please, don't do it; a kitten dies
every time you abort the installation\footnote{Of course, this statement is just a joke. No animals were 
harmed, killed or severely wounded during the making of this user manual. After all, \arara is environmentally friendly.}.

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.5]{figures/install-welcome.png}
\caption{Welcome screen.}
\label{fig:instwelcome}
\end{figure}

Moving on, the next screen shows the license agreement (Figure~\ref{fig:instlicense}). \arara is licensed under the 
\href{http://www.opensource.org/licenses/bsd-license.php}{New BSD License}~\cite{bsd:2012}. It's important to
observe that the New BSD License has been verified as a GPL-compatible free software license by the Free Software
Foundation~\cite{fsf:1985}, and has been vetted as an open source license by the Open Source Initiative~\cite{osi:1998}.
The full license is also available in this document (page~\pageref{sec:license}). You need to accept the terms of the 
license agreement before proceeding.

The next screen is probably the most important section of the installation: in here we will choose the packs we want to
install (Figure~\ref{fig:instpacks}). All packs are described in Table~\ref{tab:packs}. Note that the grayed packs are 
required.

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.5]{figures/install-packs.png}
\caption{Packs screen.}
\label{fig:instpacks}
\end{figure}

\begin{table}[htbp]
\centering
\caption{Available packs.}
\label{tab:packs}
\renewcommand{\arraystretch}{1.5}
\footnotesize
\begin{tabular}{p{0.30\textwidth}p{0.12\textwidth}p{0.4\textwidth}}
\hline
\textbf{Pack name} & \textbf{OS} & \textbf{Description}                       \\
\hline
\hline
Main application & All & This pack contains the core application. It also 
provides an |.exe| wrapper for Windows and a bash file for Unix.              \\
\hline
Include the \arara user manual & All & This pack installs this user manual into 
the |docs/| subdirectory of \arara.                                           \\
\hline
Include predefined rules & All & Of course, \arara has a set of predefined rules
for you to start with. If you prefer to write your own rules from scratch, do 
not select this pack.                                                         \\
\hline
Add a symbolic link to \arara in |/usr/local/bin| & Unix & If you ran the 
installer in privileged mode, a symbolic link to \arara can be created in the 
|/usr/local/bin| directory. There's no magic here, the installer uses the good 
old |ln| command.                                                             \\
\hline
Add \arara to the system path & Windows & Like the Unix task, \arara can also 
add itself to the system path. This feature is provided by a Windows script named
\href{http://legroom.net/software/modpath}{Modify Path}~\cite{modpath:2012}. \\
\hline
\end{tabular}
\end{table}

It's very important to mention that all these modifications in the operating 
system -- the symbolic link creation for Unix or the addition to the path for 
Windows -- are safely removed when you run the \arara uninstaller. We will talk 
about it later, in Section~\ref{sec:uninstallingarara}.

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.5]{figures/install-license.png}
\caption{License agreement screen.}
\label{fig:instlicense}
\end{figure}

In the next screen, we will select the installation path (Figure~\ref{fig:instpath}). The installer
will automatically set the default installation path according to the Table~\ref{tab:paths}, but
feel free to install \arara in your favorite structure -- even |/opt| or your home folder.

\begin{table}[htbp]
\centering
\caption{Default installation paths.}
\label{tab:paths}
\renewcommand{\arraystretch}{1.5}
\begin{tabular}{cl}
\hline
\textbf{OS} & \textbf{Default installation path}\\
\hline
\hline
Windows & |C:\Program Files\arara|\\
Unix & |/usr/local/arara|\\
\hline
\end{tabular}
\end{table}

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.5]{figures/install-path.png}
\caption{Installation path screen.}
\label{fig:instpath}
\end{figure}

After selecting the installation path, the installer will then confirm the creation of the target directory
(Figure~\ref{fig:instnewfolder}). We simply click \textit{OK} to accept it. For convenience, the full installation path 
defined in the installation path screen (Figure~\ref{fig:instpath}) will be referred as |ARARA_HOME| from now on.

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.5]{figures/install-pathwarning.png}
\caption{Target directory confirmation.}
\label{fig:instnewfolder}
\end{figure}

Now, just sit back and relax while \arara is being installed (Figure~\ref{fig:instprogress}). All selected packs will
be installed accordingly. The post installation tasks -- like creating the symbolic link or adding \arara to the system
path -- are performed here as well. If the installation has completed successfully, we will reach the final screen of
the installer congratulating us for installing \arara (Figure~\ref{fig:instfinish}).

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.5]{figures/install-progress.png}
\caption{Progress screen.}
\label{fig:instprogress}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.5]{figures/install-finish.png}
\caption{Final screen.}
\label{fig:instfinish}
\end{figure}

The full installation scheme is presented in Figure~\ref{fig:ararastructure}. The directory structure is
presented here as a whole; keep in mind that some parts will be omitted according to your operating
system and pack selection. For example, the |etc/| subdirectory will only be installed if and only if
you are in Windows and the system path pack is selected. Other files are platform-specific, such as
|arara.exe| for Windows and the |arara| bash file for Unix.

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[grow via three points={one child at (0.5,-0.7) and two children at (0.5,-0.7) and (0.5,-1.4)}, edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}, anchor=west, font=\ttfamily]
  \node {ARARA\_HOME/}
    child { node {arara.jar}}		
    child { node {arara.exe}}
    child { node {arara}}
    child { node {docs/}
      child { node {arara-usermanual.pdf}}
    }
    child [missing] {}
    child { node {etc/}
      child { node {modpath.exe}}
    }
    child [missing] {}
    child { node {Uninstaller/}
      child { node {uninstaller.jar}}
    }
	child [missing] {}
	  child { node {rules/}
        child { node {biber.yaml}}
        child { node {\ldots}}
        child { node {xetex.yaml}}
    };
\end{tikzpicture}
\caption{Installation scheme.}
\label{fig:ararastructure}
\end{figure}

That's it, \arara is installed in your operating system. If you opted for the symbolic link creation or the path addition,
\arara is already available in your terminal by simply typing |arara|. Have fun!

\section{Manual installation}
\label{sec:manualinstallation}

Thankfully, \arara is also very easy to be manually deployed. First of all, we must create the application directory.
Feel free to create this directory anywhere in your computer; it can be |C:\arara|, |/opt/arara| or another location 
of your choice. This procedure is similar to the installation path screen (Figure~\ref{fig:instpath}) from
Section~\ref{sec:installer}. Again, for convenience, the full installation path will be referred as |ARARA_HOME| from 
now on. Although it's not mandatory, try to avoid folders structures with spaces in the path. In any case,
\arara can handle such spaces.

After downloading |arara.jar| from the \href{http://github.com/cereda/arara/downloads}{downloads} section of
the project repository, let's copy it to the |ARARA_HOME| directory we've created in the previous step.
Since |arara.jar| is a self-contained, batteries-included executable Java archive file, \arara is already installed.

In order to run \arara from a manual installation, we should open a terminal and run |java -jar $ARARA_HOME/arara.jar|,
but that is far from being intuitive. To make our lives easier, we will create a shortcut for this
command.

If you are deploying \arara in Windows, there are two methods for creating a shortcut: the first method -- the
easiest -- consists of downloading the |arara.exe| wrapper from the \href{http://github.com/cereda/arara/downloads}{downloads}
section and copying it to the |ARARA_HOME| directory, in the same level of |arara.jar|. This |.exe| wrapper, provided by \href{http://launch4j.sourceforge.net}{Launch4J}~\cite{launch4j:2005}, wraps |.jar| files in Windows native executables
and allows to run them like a regular Windows program.

The second method for creating a shortcut in Windows is to provide a batch file which will call |java -jar $ARARA_HOME/arara.jar|
for us. Create a file named |arara.bat| or |arara.cmd| inside the |ARARA_HOME| directory, in the same level of |arara.jar|, and
add the content from Code~\ref{code:windows}.

\begin{code}[htbp]
\caption{Creating a batch file for \arara in Windows.}
\label{code:windows}
\begin{bash}
@echo off
java -jar "%~dp0\arara.jar" %*
\end{bash}
\end{code}

After creating the batch file, add the full |ARARA_HOME| path to the system path. Unfortunately, this manual can't cover
the path settings, since it's again a matter of personal taste. I'm sure you can find tutorials on how to add a directory to
the system path.

If you are deploying \arara in Linux or Mac, we also need to create a shortcut to |java -jar $ARARA_HOME/arara.jar|.
Create a file named |arara| inside the |ARARA_HOME| directory, in the same level of |arara.jar|, and add the content 
from Code~\ref{code:unix}.

\begin{code}[htbp]
\caption{Creating a script for \arara in Linux and Mac.}
\label{code:unix}
\begin{bash}
#!/bin/bash
# Example script of arara
# Installation and usage are described in the documentation
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ] ; do SOURCE="$(readlink "$SOURCE")"; done
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && cd -P "$( dirname "$SOURCE" )" && pwd )"
java -jar "$DIR/arara.jar" "$@"
\end{bash}
\end{code}

We now need to add execute permissions for our newly created script through |chmod +x arara|. The |arara| script can
be invoked through path addition or symbolic link. I personally prefer to add |ARARA_HOME| to my user path, but a
symbolic link creation seems way more robust -- it's what the installer does. Anyway, it's up to you to decide which method
you want to use. There's no need to use both.

Once we conclude the manual installation, it's time to check if \arara is working properly. Try running |arara| in the terminal
and see if you get the output shown in Code~\ref{code:arararun}.

\begin{code}[p]
\caption{Testing if \arara is working properly.}
\label{code:arararun}
\begin{nolanguage}
$ arara 
  __ _ _ __ __ _ _ __ __ _ 
 / _` | '__/ _` | '__/ _` |
| (_| | | | (_| | | | (_| |
 \__,_|_|  \__,_|_|  \__,_|

arara 3.0 - The cool TeX automation tool
Copyright (c) 2012, Paulo Roberto Massa Cereda
All rights reserved.

usage: arara [file [--log] [--verbose] [--timeout N] [--language L] | --help | --version]

 -h,--help             print the help message
 -L,--language <arg>   set the application language
 -l,--log              generate a log output
 -t,--timeout <arg>    set the execution timeout (in milliseconds)
 -v,--verbose          print the command output
 -V,--version          print the application version
\end{nolanguage}
\end{code}

If the terminal doesn't display the \arara logo and usage, please review the manual installation steps.
Every step is important in order to make \arara available in your system. You can also try the cross-platform
installer. If you still have any doubts, feel free to contact us.

\section{Updating \texorpdfstring{\arara}{arara}}
\label{sec:updatingarara}

If there is a newer version of \arara available in the \href{http://github.com/cereda/arara/downloads}{downloads}
section of the project repository, simply download the |arara.jar| file and copy it to the |ARARA_HOME| directory,
replacing the current one. No further steps are needed, the newer version is deployed. Try running |arara --version|
in the terminaland see if the version shown in the output is equal to the one you have downloaded.

Anyway, for every version, \arara has the proper cross-platform installer available for download in the project repository.
You can always uninstall the old \arara setup and install the new one. Please note that only major versions are released
with the installer.

If you have \arara through the \TeX\ Live distribution, the update process is straightforward: simply open a
terminal and run |tlmgr update arara| in order to update the application. This is of course the preferred method.

\section{Uninstalling \texorpdfstring{\arara}{arara}}
\label{sec:uninstallingarara}

If you want to uninstall \arara, there are two methods available. If you installed \arara through the cross-platform installer,
I have good news for you: it's just a matter of running the uninstaller. Now, if \arara was deployed through the manual
installation, we might have to remove some links or path additions.

A general Unix-based uninstallation can be triggered by the command presented in Code~\ref{code:uninstall1}.
There's also an alternative command presented in Code~\ref{code:uninstall2}.

\begin{code}[htbp]
\caption{Running the uninstaller in a Unix-based system -- method 1.}
\label{code:uninstall1}
\begin{bash}
$ sudo java -jar $ARARA_HOME/Uninstaller/uninstaller.jar
\end{bash}
\end{code}

\begin{code}[htbp]
\caption{Running the uninstaller in a Unix-based system -- method 2.}
\label{code:uninstall2}
\begin{bash}
$ su -c 'java -jar $ARARA_HOME/Uninstaller/uninstaller.jar'
\end{bash}
\end{code}

Since Windows doesn't have a similar command to |su| or |sudo|, you need to open the command prompt as administrator
and then run the command presented in Code~\ref{code:uninstallwin}. You can right-click the command prompt shortcut 
and select the ``Run as administrator\ldots'' option.

\begin{code}[htbp]
\caption{Running the uninstaller in the Windows command prompt as administrator.}
\label{code:uninstallwin}
\begin{bash}
C:\> java -jar $ARARA_HOME/Uninstaller/uninstaller.jar
\end{bash}
\end{code}

The uninstallation process will begin. Hopefully, the first and only creen of the uninstaller will appear
(Figure~\ref{fig:uninstallone}). By the way, if you called the uninstaller through the command line, please
do not close the terminal! It might end the all running processes, including our uninstaller.

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.5]{figures/uninstall-welcome.png}
\caption{The uninstaller screen.}
\label{fig:uninstallone}
\end{figure}

There's nothing much to see in the uninstaller. We have an option to force the deletion of the |ARARA_HOME| directory,
but that's all. By clicking the \textit{Uninstall} button, the uninstaller will remove the symbolic link or the path entry for
\arara from the operating system, if selected during the installation. Then it will erase the |ARARA_HOME| directory 
(Figure~\ref{fig:uninstalltwo}).

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.5]{figures/uninstall-finish.png}
\caption{The uninstaller screen, after the execution.}
\label{fig:uninstalltwo}
\end{figure}

Unfortunately, even if you force the deletion of the |ARARA_HOME| directory in Windows, the operating system can't
remove the |Uninstaller| subdirectory because the uninstaller was being executed from there. But that's the only trace 
left. You can safely delete |ARARA_HOME| after running the uninstaller.

If \arara was manually installed, we need to remove the symbolic link reference or the path entry, if any, then delete
the |ARARA_HOME| directory. Don't leave any traces of \arara in system directories or configuration files; a broken 
symbolic link or a wrong path entry might cause trouble in the future.

\printbibliography[heading=subbibliography]

\chapter{Building from sources}
\label{chap:buildingfromsources}

\epigraph{\emph{Knowledge brings fear.}}{From a \emph{Futurama} episode}

Although \arara already features a self-contained, batteries-included executable Java archive file, an |.exe| wrapper, and a cross-platform
installer, you can easily build it from sources. The only requirements are a working Java Development Kit~\cite{oracle:2012}
and the Apache Maven software project management~\cite{maven:2012}. The next sections will cover the entire process, 
from obtaining the sources to the build itself. Sadly, this manual doesn't cover Java and Maven deployments, so I kindly ask you
to check their websites and read the available documentation.

\section{Obtaining the sources}
\label{sec:obtainingthesources}

First of all, we need to get the source code, available in the project repository hosted on \href{https://github.com/cereda/arara}{GitHub}.
We have two options on how to obtain the sources: either by clicking the \href{https://github.com/cereda/arara/archive/master.zip}{Zip} button in the project page and download a snapshot
of the whole structure in an archive file, or by using |git| and clone the repository into our machine. The second option is easily done by executing the command presented in Code~\ref{code:gitobtain}, provided of course that you have |git|  installed.

\begin{code}[htbp]
\caption{Cloning the project repository.}
\label{code:gitobtain}
\begin{bash}
$ git clone git://github.com/cereda/arara.git
\end{bash}
\end{code}

After cloning the project repository (Code~\ref{code:gitobtain}), a new subdirectory named |arara| is created in the current directory
with the project structure -- the very same available in the project repository on GitHub. The application source code is inside
|arara/arara|. Note that there are other source codes for the cross-platform installer and the |.exe| wrapper, as well as the predefined
rules, each one in a subdirectory of its own.

If you opted for downloading the archive file, you'll have a file named |arara-master.zip| generated automatically by GitHub.
Just extract the file somewhere in your computer and you'll end up with the very same project structure as the one available in the
project repository.

\section{Building \texorpdfstring{\arara}{arara}}
\label{sec:buildingarara}

Inside the |arara/arara| directory, we have the most important file for building \arara: a file named |pom.xml|. We now just need to
call the |mvn| command with the proper target and relax while Maven takes care of the building process for us. First of all, let's take
a look at some targets available in our |pom.xml| file: 

\begin{ruleoptions}
\item[compile] This target compiles the source code, generating the Java bytecode.
\item[package] The |package| target is very similar to the |compile| one, but instead of only compiling the source code, it also
packs the Java bytecode into an executable Java archive file without dependencies. The file will be available inside the
|arara/arara/target| directory.
\item[assembly:assembly] This target is almost identical to the |package| one, but it also includes all the dependencies into a
final Java archive file. The file will be available inside the |arara/arara/target| directory. This is of course our preferred target,
since \arara is shipped as a self-contained executable Java archive file.
\item[clean] The |clean| target removes all the generated Java bytecode and deployment traces, cleaning the project structure.
\end{ruleoptions}

Now that we know the targets, we only need to call |mvn| with the target we want. If you want to generate the very same Java archive file
we use for releases, execute the command presented in Code~\ref{code:mvnassembly}.

\begin{code}[htbp]
\caption{Building \arara with Maven, first attempt.}
\label{code:mvnassembly}
\begin{bash}
$ mvn assembly:assembly
\end{bash}
\end{code}

Actually, the command presented in Code~\ref{code:mvnassembly}, as the project structure is at the moment, will fail! Let me explain
why: the application is not yet linked with the localized messages, so we need to convert our translation files into a correct format and
then run the target in Maven. The error message after running |mvn assembly:assembly| presented in Code~\ref{code:errorlangnotfound}
gives us a hint on what we should do.

\begin{code}[htbp]
\caption{The Maven error message about missing localization files.}
\label{code:errorlangnotfound}
\begin{bash}
Failed tests: testLocalizationFile(com.github.arara.AraraTest):
arara requires at least the default localization file
Messages.properties located at the translations/ directory in
the project repository. Rename Messages.input to
Messages.properties and copy the new file to the src/
directory, under com/github/arara/localization, and build
arara again.

Tests run: 1, Failures: 1, Errors: 0, Skipped: 0

[INFO] ---------------------------------------------
[INFO] BUILD FAILURE
[INFO] ---------------------------------------------
\end{bash}
\end{code}

Let's go into |arara/translations| and run the commands presented in Code~\ref{code:convertinglocales}. Since we are dealing with
languages that require an encoding in UTF-8 while the localization files are set in ASCII, we need to run a conversion program in
order to generate valid |.properties|  files.

\begin{code}[htbp]
\caption{Converting the localization files.}
\label{code:convertinglocales}
\begin{bash}
$ native2ascii -encoding utf8 Messages.input ../application/src/main/resources/com/github/arara/localization/Messages.properties
$ native2ascii -encoding utf8 Messages_de.input ../application/src/main/resources/com/github/arara/localization/Messages_de.properties
$ native2ascii -encoding utf8 Messages_es.input ../application/src/main/resources/com/github/arara/localization/Messages_es.properties
$ native2ascii -encoding utf8 Messages_fr.input ../application/src/main/resources/com/github/arara/localization/Messages_fr.properties
$ native2ascii -encoding utf8 Messages_it.input ../application/src/main/resources/com/github/arara/localization/Messages_it.properties
$ native2ascii -encoding utf8 Messages_pt_BR.input ../application/src/main/resources/com/github/arara/localization/Messages_pt_BR.properties
$ native2ascii -encoding utf8 Messages_ru.input ../application/src/main/resources/com/github/arara/localization/Messages_ru.properties
$ native2ascii -encoding utf8 Messages_tr.input ../application/src/main/resources/com/github/arara/localization/Messages_tr.properties
\end{bash}
\end{code}

Now we can simply rerun the command presented in Code~\ref{code:mvnassembly}. Hopefully, we won't have trouble this time.
Relax while Maven takes care of the building process. It might take a while, since all dependencies will be downloaded to your Maven repository. After a while, Maven will tell us that the project was built successfully!

After a successful build via Maven, we can now get the generated executable Java archive file |arara-3.0-with-dependencies.jar| which is inside the |arara/arara/target| directory, rename it to |arara.jar| and use it as we have seen in the previous chapters.

\section{Notes on the installer and wrapper}
\label{sec:notesontheinstallerandwrapper}

The project directory has additional subdirectories regarding the \arara cross-platform installer and the |.exe| wrapper. It's important to
observe that only the build files are available, which means that you need to review the compilation process and make adjustments
according to your directory structure. 

The cross-platform installer Java archive file is generated with IzPack~\cite{izpack:2001}, while the |.exe| wrapper is built with
Launch4J~\cite{launch4j:2005}. Both build files are written in plain XML, so you can easily adapt them to your needs. Sadly, the main
purpose of this chapter is to cover the build process of \arara itself and not its helper tools; if you want to generate your own wrapper
or installer, please refer to the available documentation on how to build each file. The build process is also very straightforward.

\printbibliography[heading=subbibliography]

\chapter{IDE integration}
\label{chap:ideintegration}

\epigraph{\emph{The answer to ``can Emacs\ldots'' is always ``yes''.}}{David Carlisle}

This chapter covers the integration of \arara with several integrated development environments. For obvious reasons, it's almost
impossible for us to cover the full range of editors available nowadays, so we tried to focus only on a couple of them. If you use
\arara with an IDE other than the ones listed here, please let us know! It would be great to include your contribution in this user
manual.

\section{\texorpdfstring{\TeX works}{TeXworks}}
\label{sex:texworks}

\arara can be easily integrated with \TeX works~\cite{texworks:2009}, an environment for authoring \TeX\ documents shipped
with both \TeX\ Live and MiK\TeX. In this section, we will learn how to integrate \arara and this cross-platform \TeX\ front-end
program.

First of all, make sure \arara is properly installed in your operating system. Thankfully, it's very easy to add a new tool in \TeX works,
just open the program and click in \textit{Edit} $\rightarrow$ \textit{Preferences\ldots} to open the preferences screen (Figure~\ref{fig:texworkspref}).

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.5]{figures/texworks-prefs.png}
\caption{Opening the preferences screen in \TeX works.}
\label{fig:texworkspref}
\end{figure}

The next screen is the \TeX works preferences (Figure~\ref{fig:texworksprefscreen}). There are several tabs available. Navigate to the
\textit{Typesetting} tab, which contains two lists: the paths for \TeX\ and related programs, and the processing tools. In the second
list -- the processing tools -- click the \textit{Plus (+)} button to add another tool.

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.5]{figures/texworks-add.png}
\caption{The \TeX works preferences screen.}
\label{fig:texworksprefscreen}
\end{figure}

We are now in the new tool screen (Figure~\ref{fig:texworksarara}). \TeX works provides an very straightforward interface for adding
new tools; we just need to provide the tool name, the executable path, and the parameters. Table~\ref{tab:texworksarara} helps us on
what to type in each field. When done, just click \textit{OK} and our new tool will be available.

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.5]{figures/texworks-arara.png}
\caption{The new tool screen.}
\label{fig:texworksarara}
\end{figure}

{\renewcommand{\arraystretch}{1.5}
\begin{table}[htbp]
\centering
\footnotesize
\begin{tabular}{p{0.15\textwidth}p{0.25\textwidth}p{0.50\textwidth}}
\hline
\textbf{Field name} & \textbf{Value} & \textbf{Description}                   \\
\hline
\hline
Name & |arara| & The tool name. You can actually type whatever name your heart 
desires. This value will be displayed in the compilation profile.             \\
\hline
Program & |$ARARA_HOME/arara| & The full executable path. Just browse the 
filesystem and select the correct \arara path. Observe that symbolic links are 
resolved to their full targets. For Windows, select the |.exe| wrapper; for 
Unix, select the bash script.                                                 \\
\hline
Arguments & {\renewcommand{\arraystretch}{1}
\begin{tabular}[t]{l}
|$fullname|\\
|--verbose|\\
|--log|
\end{tabular}} & The tool arguments. Note that you need to type one argument at 
a time, by clicking the \textit{Plus (+)} button. The first argument is a 
\TeX works variable which will expand to the current filename. The second and
third arguments are \arara flags, discussed later, in 
Chapter~\ref{chap:runningarara}.                                            \\
\hline
\end{tabular}
\caption{Configuring \arara in \TeX works.}
\label{tab:texworksarara}
\end{table}}

We are now back to the preferences screen (Figure~\ref{fig:texworksprefscreen}). Hopefully, \arara is in the list of processing tools.
Just click \textit{OK} to confirm the new addition. Congratulations, now \arara is available as a compilation profile in \TeX works
(Figure~\ref{fig:texworksprofile}).

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.5]{figures/texworks-profile.png}
\caption{Using \arara in the \TeX works compilation profile.}
\label{fig:texworksprofile}
\end{figure}

And we are done, \arara is now integrated with \TeX works! Just make sure to select the correct profile when running the compilation
process.

\section{\texorpdfstring{\TeX nic Center}{TeXnic Center}}
\section{Kile}
\section{\texorpdfstring{\TeX maker}{TeXmaker}}
\section{\texorpdfstring{\TeX studio}{TeXstudio}}
\section{WinEdt}
\section{Inlage}
\section{\texorpdfstring{\TeX Shop}{TeXShop}}

\printbibliography[heading=subbibliography]

\chapter{Important concepts}
\label{chap:importantconcepts}

\epigraph{\emph{Beware of bugs in the above code; I have only proved it correct, not tried it.}}{Donald Knuth}

Time for our first contact with \arara! It's important to understand a few concepts in which \arara relies before we proceed
to the usage itself. Do not worry, these concepts are easy to follow, yet they are vital to the comprehension of the application
and the logic behind it.

\section{Rules}
\label{sec:rules}

Do you remember |mydoc.tex| from Code~\ref{code:hellolatex} in page~\pageref{code:hellolatex}? When we tried to mimic |rubber| and
run |arara mydoc|, nothing happened. We should tell \arara how it should handle this execution. Let's start with the rules.

A \emph{rule} is a formal description of how \arara should handle a certain task. For example, if we want to use |pdflatex| with
\arara, we should have a rule for that. Once a rule is defined, \arara automatically provides an access layer to that rule through
directives, a concept to be introduced in Section~\ref{sec:directives}.

A rule is a plain text file written in the YAML format~\cite{yaml:2001}. I opted for this format because it's cleaner and more intuitive to
use than other markup languages, besides of course being a data serialization standard for all programming languages. As a bonus, the
acronym \emph{YAML} rhymes with the word \emph{camel}, so \arara is heavily environmentally friendly\footnote{Perl, I'm looking at you.}.

The default rules, that is, the rules shipped with \arara, are placed inside a special subdirectory named |rules/| inside |ARARA_HOME|. We will learn in
Section~\ref{sec:searchpaths} that we can add an arbitrary number of paths for storing our own rules, in order of priority, so don't worry
with the location of the default rules, although it's important to understand and acknowledge their existance.  The basic structure of an
\arara rule is presented in Code~\ref{code:yamlrule}.

\begin{code}[htbp]
\caption{\mycmd{makefoo.yaml}, a basic structure of an \arara rule.}
\label{code:yamlrule}
\begin{yaml}
!config
# I am a comment
identifier: makefoo
name: MakeFoo
command: makefoo @{file}
arguments: []
\end{yaml}
\end{code}

The |!config| keyword (line 1) is mandatory and it must be the first line of any \arara rule. Note that the format also accepts
comments (line 2) by simply starting a line with the |#| symbol. The following keys are defined:

\begin{ruleoptions}
\item[identifier] This key (line 3) acts as a unique identifier for the rule. It's highly recommended to use lowercase letters without
spaces, accents or punctuation symbols. As a convention, if you have an identifier named |makefoo|, the rule filename must
be |makefoo.yaml|.
\item[name] The |name| key (line 4) holds the name of the task. When running \arara, this value will be displayed in the output.
In our example, \arara will display |Running MakeFoo| in the output when dealing with this task.
\item[command] This key (line 5) contains the system command to be executed. You can use virtually any type of command,
interactive or noninteractive. But beware: if \arara is running in silent mode, which is the default behaviour, an 
interactive command wich might require the user input will be halted and the execution will fail. Don't despair, you can use a
special |--verbose| flag with \arara in order to interact with such commands -- we will talk about flags in 
Chapter~\ref{chap:runningarara}. There are cases in which you might want to have a list of commands instead of a single one;
\arara has support for multiple commands inside one rule, we just need to replace |command| by |commands|  and provide
a list of commands to be executed, as seen in Code~\ref{code:excommands}.
You probably noticed a strange element |@{file}| in the |command| line: this element is called \emph{orb tag}. For now, just admit these elements exist. We will come back to them later on, in Section~\ref{sec:orbtags}, I promise.
\item[arguments] The |arguments| key (line 6) denotes a list of arguments for the rule command. In our example, we have an empty list,
denoted as |[]|. You can define as many arguments as your command requires. Please check Code~\ref{code:makebar} for an example of a list of arguments.
\end{ruleoptions}

There are cases in which we need to run more than just one command for a certain rule. Take, for example, the |frontespizio| rule
released with \arara: when using the |frontespizio|  package\footnote{\url{http://ctan.org/pkg/frontespizio}, written by Enrico Gregorio.},
the document has to processed by the choosen engine, say |pdflatex|, no less than three times; if |latex| is used, there's an additional
run of |dvips|. In that case, the logic is enclosed inside the rule, so there's no need to write every compilation step as required by the
package as directives in the source code; a simple call to |frontespizio| is enough to generate the proper results.

If you need to run more than one command inside a rule, replace the |command| identifier by |commands| and add one command per line,
preceeded by |-| to indicate an item in the list. Code~\ref{code:excommands} presents a sample |makefoobar| rule which runs the
|makefoo| program two times, followed by one run of the |makebar| program.

\begin{code}[htbp]
\caption{\mycmd{makefoobar.yaml}, an \arara rule with multiple commands.}
\label{code:excommands}
\begin{yaml}
!config
identifier: makefoobar
name: MakeFooBar
commands:
- makefoo @{file}
- makefoo @{file}
- makebar @{file}
arguments: []
\end{yaml}
\end{code}

For more complex rules, we might want to use arguments. Code~\ref{code:makebar} presents a new rule which makes use of them
instead of an empty list as we saw in Code~\ref{code:yamlrule}.

\begin{code}[htbp]
\caption{\mycmd{makebar.yaml}, a rule with arguments.}
\label{code:makebar}
\begin{yaml}
!config
identifier: makebar
name: MakeBar
command: makebar @{one} @{two} @{file}
arguments:
- identifier: one
   flag: -i @{parameters.one}
- identifier: two
   flag: -j @{parameters.two}
\end{yaml}
\end{code}

For every argument in the |arguments| list, we have a |-| mark and the proper indentation. The required keys for an argument are:

\begin{ruleoptions}
\item[identifier] This key (lines 6 and 8) acts as a unique identifier for the  argument. It's highly recommended to use lowercase letters
without spaces, accents or punctuation symbols.
\item[flag] The |flag| key (lines 7 and 9) represents the argument value. Note that we have other orb tags in the arguments definitions,
|@{parameters.one}| and |@{parameters.two}|; we will discuss them later on, in Section~\ref{sec:orbtags}. Just to give some context,
|parameters| is a special keyword which maps the elements available in the directives. For example, if we have |one: 1| in a directive,
|parameters.one| will resolve to |1|. The argument |flag| value is only triggered, that is, resolved, if and only if there's an explicit directive argument. Say, if |one| is not defined as a directive argument, the |flag| value of the argument |one| will be resolved to an empty string. There's a way of overriding the default empty string value when a directive argument is not specified, which is done by using the |default| key.
By the way, the |flag| key is not really mandatory, but for most of the rules, you'll need it. At least one of the |flag| and |default| keys is
mandatory.
\end{ruleoptions}

If we need to set a default value other than an empty string to a rule argument, we can use the |default| key. When a rule argument just needs
a default value, you can safely ignore the |flag| key and rely on the |default| key. If you need to map a directive argument into a rule argument
without falling back to a default value different than an empty string, just use the |flag| key. Now, if you need mapping and fallback,
stick with both keys.

For now, we need to keep in mind that \arara uses rules to tell it how to do a certain task. In the next sections, when more concepts are
presented, we will come back to this subject. Just a taste of things to come, as we mentioned before already: directives are mapped to rules through orb tags. Don't worry, I'll explain how things work.

\section{Directives}
\label{sec:directives}

A \emph{directive} is a special comment inserted in the |.tex| file in which you indicate how \arara should behave. You can
insert as many directives as you want, and in any position of the |.tex| file. \arara will read the whole file and extract the directives.
A directive should be placed in a line of its own, in the form |% arara: <directive>| -- actually, we will see in Section~\ref{sec:filepatterns}
that the prefix search can be altered. There are two types of directives:

\begin{description}
\item[empty directive]  An empty directive, as the name indicates, has only the rule identifier, as we seen in Section~\ref{sec:rules}.
Lines 1 and 3 of Code~\ref{code:directiveslatex} show an example of empty directives. Note that you can suppress arguments
(line 3 in contrast to line 2), but we will see that \arara assumes that you know exactly what you are doing. The syntax for an empty 
directive is |% arara: makefoo|.
\item[parametrized directive] A parametrized directive has the rule identifier followed by its arguments. Line 2 of Code~\ref{code:directiveslatex} shows an 
example of a parametrized directive. It's very important to mention that the arguments are mapped by their identifiers and not by
their positions. The syntax for a parametrized directive is |% arara: makefoo: { arglist }|. The argument is in the form |arg: value|; a
list of arguments and their respective values is separated by comma.
\end{description}

\begin{code}[htbp]
\caption{Example of directives in a .tex file.}
\label{code:directiveslatex}
\begin{latex}
%% (*@@*)arara: makefoo
%% (*@@*)arara: makebar: { one: hello, two: bye }
%% (*@@*)arara: makebar
\documentclass{article}
...
\end{latex}
\end{code}

The arguments are defined according to the rule mapped by the directive. For example, the rule |makebar| (Code~\ref{code:makebar})
has a list of two arguments, |one| and |two|. So you can safely write |makebar: { one: hello }|, but trying to map a nonexisting argument
with |makebar: { three: hi }| will raise an error.

If you want to disable an \arara directive, there's no need of removing it from the |.tex| file. Simply replace |% arara:| by |% !arara:| and
this directive will be ignored. \arara always look for a line that, after removing the leading and trailing spaces, starts with a comment |%|
and has the keyword |arara:| in it. In Section~\ref{sec:filepatterns}, we will learn how to override this search pattern, but the |arara:|
keyword is always immutable.

Directives are mapped to rules. In Section~\ref{sec:orbtags} we will learn about orb tags and then revisit rules and directives. I hope the concepts will be clearer since we will understand what an orb tag is and how it works. How about a nice cup of coffee?

\section{Orb tags}
\label{sec:orbtags}

When I was planning the mapping scheme, I opted for a templating mechanism. I was looking for flexibility, and the powerful 
\href{http://mvel.codehaus.org}{MVEL} expression language~\cite{mvel:2012} was perfect for the job. I could extend my mapping
plans by using orb tags. An \emph{orb tag} consists of a |@| character followed by braces |{...}| which contain regular MVEL expressions.
In particular, \arara uses the |@{}| expression orb, which contains a value expression which will be evaluated to a string, and 
appended to the output template. For example, the following template |Hello, my name is @{name}| with the |name| variable resolving
to |Paulo| will be expanded to the string |Hello, my name is Paulo|. Cool, isn't it? Code~\ref{code:exorbtags} presents a few examples
on how orb tags are expanded.

\begin{code}[htbp]
\caption{A few examples on how orb tags are expanded.}
\label{code:exorbtags}
\begin{bash}
# always consider: name = Paulo

In[1]: Hello, my name is @{name}.
Out[1]: Hello, my name is Paulo.

In[2]: @{name == "Paulo"}
Out[2]: true

In[3]: @{name.toUpperCase()}
Out[3]: PAULO

In[4]: Hello, I am @{name == "Paulo" ? "John" : "Mary"}.
Out[4]: Hello, I am John.
\end{bash}
\end{code}

In the first example of Code~\ref{code:exorbtags}, |@{name}| simply indicates the expansion of the variable into its value, so the output is a
concatenation of the text with the variable value. The second example is a conditional test, that is, whether the |name|  variable has its
value equals to |Paulo|; the result of this evaluation is then expanded, which is |true|. The third example presents a more complex construction: since |name| holds a string, MVEL resolves this variable to a |String| object and automatically all methods from the |String| class in Java are available to the variable, so the method |toUpperCase()| is called in order to make all characters in the string to be capitalized, and the output is presented. The fourth and last example presents a ternary operation, which starts with a conditional to be evaluated; if this test evaluates to true, the first string is printed, with the second string being printed in case the test is false.

When mapping rules, every command argument will be mapped to the form |@{identifier}| with value equals to the content of the |flag| key.
The |@{identifier}| orb tag might hold the value of the |default| key instead, if the key is defined and there were no directive parameters
referring to |identifier|. There are three reserved orb tags, |@{file}|, |@{item}| and |@{parameters}| -- actually, that's not true, there's a
fourth reserved orb tag which plays a very special role in \arara \ -- |@{SystemUtils}| -- but we will talk about it later on. The |@{file}|
orb tag refers to the filename argument passed to \arara. The |@{file}| value can be overriden, but we will discuss it later. The second
reserved orb tag |@{item}| refers to a list of items, in case the rule might use some sort of list iteration, discussed later on. The
third reserved orb tag |@{parameters}| is a map which can expand to the argument value passed in the directive. If you have |makebar: { one: hello }|, the |flag| key of argument |one| will be expanded from the original definition |-i @{parameters.one}| to |-i hello|. Now |@{one}| contains the expanded |flag| value, which is |-i hello|. All arguments tags are expanded in the rule command. If one of them is not defined in the directive, \arara will admit an empty value, so the |command| flag will be expanded to |makebar -i hello mydoc|, unless of course the current argument doesn't have a |default| elements in its definition. The whole procedure is summarized as follows:

\begin{enumerate}
\item \arara processes a file named |mydoc.tex|.
\item A directive |makebar: { one: hello }| is found, so \arara will look up the rule |makebar.yaml| (Code~\ref{code:makebar}) inside the default rules directory. 
\item The argument |one| is defined and has value |hello|, so the corresponding |flag| key will have the orb tag |@{parameters.one}| expanded to |hello|. The new value is now added to the template referenced by the |command| key and then |@{one}| is 
expanded to |-i hello|.
\item The argument |two| is not defined, so the template referenced by the |command| key has |@{two}| expanded to an empty string, since there's no |default| key in the argument definition.
\item There are no more arguments, so the template referenced by the |command| key now expands |@{file}| to |mydoc|.
\item The final command is now |makebar -i hello mydoc|.
\end{enumerate}

There's a reserved directive key named |files|, which is in fact a list. In case you want to override the default value of the |@{file}| orb tag, use the |files| key,
like |makebar: { files: [ thedoc.tex ] }|. This will result in |makebar thedoc.tex| instead of |makebar mydoc.tex|. The very same concept applies
to the other reserved directive key named |items|, which is also a list, and the expansion happens in the |@{item}| orb tag.

If you provide more than one element in the list, \arara will replicate the directive for every file found, so  |makebar: { files: [ a, b, c ] }| will 
result in three commands: |makebar a|, |makebar b| and |makebar c|. If you happen to have a rule which makes use of both |files|  and
|items| in the directive, you'll end up with a cartesian product of those two lists.

\printbibliography[heading=subbibliography]

\chapter{Configuration file}
\label{chap:configurationfile}

\epigraph{\emph{An algorithm must be seen to be believed.}}{Donald Knuth}

\arara has support for an optional configuration file in order to enhance and override some settings of the application without the need of delving into the source code. The optional configuration file has to reside inside the user home directory, which is usually |C:\Users\Username| for Windows Vista and superior, or |~/username| for the Unix world, under the name |araraconfig.yaml|. \arara always looks for a configuration file during every execution. In fact, |araraconfig.yaml| is just a plain text file written in the YAML format, starting with the |!config| line and at with least one of the three settings presented in the following sections. The order doesn't matter, as long as they are consistent.

\section{Search paths}
\label{sec:searchpaths}

When looking for rules, \arara always searches the default rule path located at |ARARA_HOME/rules|; if no rule is found, the execution
halts with an error. It's not wise to mess with the default rule path, so we use the configuration file to add search paths, that is, a list of
directories in which \arara should look for rules. An example of a new search path is presented in Code~\ref{code:searchone}.

\begin{code}[htbp]
\caption{An example of a new search path for the configuration file.}
\label{code:searchone}
\begin{yaml}
!config
paths:
- /home/paulo/rules
\end{yaml}
\end{code}

According to Code~\ref{code:searchone}, from now on, \arara will look for rules first in the |/home/paulo/rules|; if the rule is not found,
then the search falls back to the default search path located at |ARARA_HOME/rules|. We can even add an arbitrary number of paths, as seen in Code~\ref{code:searchtwo}.

\begin{code}[htbp]
\caption{An arbitrary number of paths added in the configuration file.}
\label{code:searchtwo}
\begin{yaml}
!config
paths:
- /home/paulo/rules
- /opt/arara/rules
- /home/paulo/myrules
\end{yaml}
\end{code}

The items order defines the search priority. \arara also features a special orb tag for search paths named |@{userhome}| which maps the variable to the user home directory, for example, |/home/paulo|, according to your operating system. But before we proceed, a word on the YAML format.

Sadly, we can't start values with |@| because this symbol is reserved for future use in the YAML format. For example, |foo: @bar| is an invalid YAML format, so the correct usage is to enclose it in quotes: |foo: '@bar'| or |foo: "@bar"|. We also need to enclose our strings with quotes in \arara, but now we can save them by simply adding the |<arara>| prefix to the value. In other words, |foo: <arara > @bar| is correctly parsed; when that keyword in that specific position is found, \arara removes it. That means that the orb tag presented in Code~\ref{code:searchthree} will be correctly parsed.

\begin{code}[htbp]
\caption{Using the special orb tag for mapping the home directory in the configuration file.}
\label{code:searchthree}
\begin{yaml}
!config
- '@{userhome}/rules'
- /opt/arara/rules
- <arara> @{userhome}/myrules
\end{yaml}
\end{code}

It's important to observe that the |<arara>| prefix is also valid in the rules context, presented in Section~\ref{sec:rules}. The idea of using this prefix is to actually ease the writing of rules that involve quoting without the need of escaping all internal quotes or even alternating between single and double quotes. It's also a way of writing cleaner rules.

\section{Language}
\label{sec:language}

\arara currently features localized messages in English, French, Italian, German, Brazilian Portuguese, Russian and Turkish. The default language fallback is English, but we can easily change the language by adding |language: <code>| to the configuration file, as seen in Code~\ref{code:conflang}. The list of languages and codes is presented in Table~\ref{tab:langcodeconf}.

\begin{code}[htbp]
\caption{Changing the language in the configuration file.}
\label{code:conflang}
\begin{yaml}
!config
language: en
\end{yaml}
\end{code}

\begin{table}[htbp]
\centering
\caption{Languages and codes.}
\label{tab:langcodeconf}
\renewcommand{\arraystretch}{1.5}
\begin{tabular}{lr}
\hline
\textbf{Language} & \textbf{Code}                       \\
\hline
\hline
English & |en| \\
Brazilian Portuguese & |ptbr| \\
Italian & |it| \\
German & |de| \\
French & |fr| \\
Russian & |ru| \\
Turkish & |tr|
\end{tabular}
\end{table}

There's also a |--language| command line flag which has a higher priority, so it overrides the configuration file setting, if any. Beware of the terminal you use; the Windows command prompt has serious troubles in understanding UTF-8. You probably won't run into problems with the applications shipped in Mac or Linux.

\section{File patterns}
\label{sec:filepatterns}

\arara accepts the following filetypes: |tex|, |dtx| and |ltx|. If no file extension is provided in the command line, for example, calling |arara mydoc| instead of |arara mydoc.tex|, the application will automatically look for files that match the filetypes in that specific order, that is, |mydoc.tex|, |mydoc.dtx| and |mydoc.ltx|. Let's say we want to change the order by promoting |dtx| to the first match; we can easily achieve that by rearranging the items of the list of filetypes in the configuration file according to Code~\ref{code:itemsconf}.

\begin{code}[htbp]
\caption{Rearranging the list of filetypes in the configuration file.}
\label{code:itemsconf}
\begin{yaml}
!config
filetypes:
- extension: dtx
- extension: tex
- extension: ltx
\end{yaml}
\end{code}

The |filetypes| key in the configuration file is actually way more powerful than the example shown in Code~\ref{code:itemsconf}. Before
we continue, let's start with some basics. Consider the three directives presented in Code~\ref{code:confdirectives}.

\begin{code}[htbp]
\caption{Three directives with different formatting patterns.}
\label{code:confdirectives}
\begin{latex}
% (*@@*)arara: foo
    % (*@@*)arara: foo
% (*@@*)       arara: foo
\documentclass{book}
...
\end{latex}
\end{code}

The default setting for \arara is to recognize the three directives shown in Code~\ref{code:confdirectives}. In other words, the search pattern for all the three extensions is |^(\\s)*%\\s+| plus |arara:\\s| which is immutable, of course. Let’s say that, for the |dtx| format, you want
\arara to look for directives that have no spaces in the beginning of the line, that is, the line must start with only one percentage sign followed by at least one space and the default prefix. We can easily achieve such requirement by adding a |pattern| element to our list, as presented in Code~\ref{code:confdirectivessearch}.

\begin{code}[htbp]
\caption{Changing the search pattern for \mycmd{.dtx} files.}
\label{code:confdirectivessearch}
\begin{yaml}
!config
!config filetypes:
- extension: dtx
   pattern: ^%\\s+
- extension: tex
- extension: ltx
\end{yaml}
\end{code}

Now, only the first directive of Code~\ref{code:confdirectives} is recognized, if the analyzed file has the |.dtx| extension. All other extensions -- |.tex|  and |.ltx| -- will follow the default search pattern.

We can also extend \arara to analyze files with arbitrary extensions. As an example, let's suppose we have a sample |hello.c| file, presented in Code~\ref{code:helloc}. Note that the code was omitted for obvious reasons, since we are interested in the header.

\begin{code}[htbp]
\caption{A sample \mycmd{hello.c} code.}
\label{code:helloc}
\begin{clang}
// arara: gcc
#include <stdio.h>
...
\end{clang}
\end{code}

We can add the |.c| extension to be recognized by \arara by simply adding the extension and search pattern entries in the configuration file, as presented in Code~\ref{code:confc}.

\begin{code}[htbp]
\caption{Adding support for \mycmd{.c} files in the configuration file.}
\label{code:confc}
\begin{yaml}
!config
filetypes:
- extension: c
   pattern: ^\\s*//\\s*
\end{yaml}
\end{code}

Done, now \arara can support |.c| files! We can run |arara hello.c| and have our code compiled, provided we have a |gcc| rule, of course.  The extensions list will be |.tex|, |.dtx|, |.ltx| and |.c|. If you want to change the order, it’s a matter of rearranging the items, as shown in Code~\ref{code:confctwo}.

\begin{code}[htbp]
\caption{Rearranging items of arbitrary extensions in the configuration file.}
\label{code:confctwo}
\begin{yaml}
!config
filetypes:
- extension: c
   pattern: ^\\s*//\\s*
- extension: tex
- extension: dtx
- extension: ltx
\end{yaml}
\end{code}

From now on, the |.c| has priority over all other extensions. It's very important to note that for customized extensions, the |pattern| key is mandatory. For default extensions, use the |pattern| key if and only if you want to override the search pattern.

\chapter{Running arara}
\label{chap:runningarara}

\section{Command line}
\section{Messages}
\section{Command output}
\section{Logging}

\part{For authors}

\chapter{Quick start}
\section{Predefined rules}
\section{Organizing directives}
\section{Best practices}

\chapter{Reference for rule library}
\label{chap:referenceforrulelibraryone}

\section{Directives and arguments}
\label{sec:directivearguments}

\section{Special orb tags}
\label{sec:specialorbtags}

\part{For rulemakers}

\chapter{Quick start}
\section{Writing rules}
\section{Cross-platform rules}
\section{Best practices}

\chapter{Reference for rule library}
\label{chap:referenceforrulelibrarytwo}

\section{Functions}
\label{sec:functions}

\section{Notes on expansion}
\label{sec:notesonexpansion}

\part{Structure and execution}

\chapter{Inside the rule format}
\section{Available fields}
\section{Expansion order}
\section{Processing rules}

\chapter{Inside the application}
\section{Looking for directives}
\section{Mapping directives to rules}
\section{Executing commands}

\end{document}
